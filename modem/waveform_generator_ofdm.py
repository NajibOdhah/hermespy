from typing import List, Tuple

import numpy as np
from scipy import signal

from modem.waveform_generator import WaveformGenerator
from parameters_parser.parameters_ofdm import ParametersOfdm
from modem.tools.psk_qam_mapping import PskQamMapping


class WaveformGeneratorOfdm(WaveformGenerator):
    """This module provides a class for a generic OFDM modem, with a flexible frame configuration.

    The following features are supported:
    - The modem can transmit or receive custom-defined frames. (see class ParametersOfdm). The frame may contain UL/DL data
    symbols, pilot subcarriers, reference signals and guard intervals.
    - SC-FDMA can also be implemented with a precoder.
    - Subcarriers can be modulated with BPSK/QPSK/16-/64-/256-QAM.
    - Zero-padded or cyclic-prefix OFDM are supported.

    This implementation has currently the following limitations:
    - SISO only
    - hard output only (no LLR)
    - all subcarriers use the same modulation scheme
    - ZF equalizer only (good enough for cyclic-prefix OFDM)
    - reference is a random
    - ideal channel estimation assumed
    - precoding not implemented
    - pilot not implemented
    """

    def __init__(self, param: ParametersOfdm,
                 rng: np.random.RandomState) -> None:
        """Creates a modem object.

        Args:
            param(ParametersOfdm): object containing all the relevant parameters
            source(BitsSource): bits source for transmitter
            rng(numpy.random.RandomState): random number generator (used for random reference signal)
        """
        super().__init__(param)
        self.param = param
        self._samples_in_frame_no_oversampling = 0

        self._mapping = PskQamMapping(self.param.modulation_order)

        self._rand = rng

        initial_index = self.param.fft_size - \
            int(np.ceil(self.param.number_occupied_subcarriers / 2))
        self._resource_element_mapping = np.arange(
            initial_index, self.param.fft_size)
        final_index = int(np.floor(self.param.number_occupied_subcarriers / 2))
        self._resource_element_mapping = np.append(
            self._resource_element_mapping, np.arange(
                1, final_index + 1))

        cyclic_prefix_length = 0
        number_cyclic_prefix_samples = 0
        number_of_data_samples = 0

        for frame_element in self.param.frame_structure:
            self._samples_in_frame_no_oversampling += frame_element.number_of_samples

            if frame_element.type == self.param.link_direction:
                number_of_data_samples += frame_element.number_of_samples
                number_cyclic_prefix_samples += cyclic_prefix_length

            if frame_element.type == ParametersOfdm.element_types.CYCLIC_PREFIX:
                cyclic_prefix_length = frame_element.number_of_samples
            else:
                cyclic_prefix_length = 0

        self._cyclic_prefix_overhead = (
            number_of_data_samples + number_cyclic_prefix_samples) / number_of_data_samples

    ###################################
    # property definitions

    @property
    def samples_in_frame(self) -> int:
        """int: Returns read-only samples_in_frame"""
        return self._samples_in_frame_no_oversampling * self.param.oversampling_factor

    @property
    def bits_in_frame(self) -> int:
        """int: Returns read-only bits_in_frame"""
        return self.param.bits_in_frame

    @property
    def cyclic_prefix_overhead(self) -> float:
        """int: Returns read-only cyclic_prefix_overhead"""
        return self._cyclic_prefix_overhead

    # property definitions END
    #############################################

    def create_frame(self, timestamp: int,
                     data_bits: np.array) -> Tuple[np.ndarray, int, int]:
        """Creates a modulated complex baseband signal for a whole transmit frame.

        The signal will be modulated based on the bits generated by "self.source".

        Args:
            timestamp(int): timestamp (in samples) of initial sample in frame
            data_bits (np.array):
                Flattened blocks, whose bits are supposed to fit into this frame.

        Returns:
            (np.ndarray, int, int):
                `output_signal(numpy.ndarray)`: 1D array containing the transmitted signal with self.samples_in_frame elements
                `timestamp(int)`: current timestamp (in samples) of the following frame
                `initial_sample_num(int)`: sample in which this frame starts (equal to initial timestamp)
        """
        output_signal = np.zeros(
            self._samples_in_frame_no_oversampling,
            dtype=complex)
        symbols_in_frame = self._mapping.get_symbols(data_bits)

        sample_index = 0
        cyclic_prefix_samples = 0
        for frame_element in self.param.frame_structure:
            if (frame_element.type == ParametersOfdm.element_types.GUARD_INTERVAL or
                    frame_element.type == ParametersOfdm.element_types.ZERO_PREFIX):
                sample_index += frame_element.number_of_samples
            elif frame_element.type == self.param.non_link_direction:
                sample_index += cyclic_prefix_samples + frame_element.number_of_samples
            elif (frame_element.type == self.param.link_direction or
                  frame_element.type == ParametersOfdm.element_types.REFERENCE):

                if frame_element.type == self.param.link_direction:
                    ofdm_symbol, symbols_in_frame = self.create_data_symbol(
                        symbols_in_frame, cyclic_prefix_samples)
                else:
                    ofdm_symbol = self.create_reference_symbol(
                        cyclic_prefix_samples)

                output_signal[sample_index:sample_index +
                              ofdm_symbol.shape[0]] = ofdm_symbol
                sample_index += ofdm_symbol.shape[0]

            if frame_element.type != ParametersOfdm.element_types.CYCLIC_PREFIX:
                cyclic_prefix_samples = 0
            else:
                cyclic_prefix_samples = frame_element.number_of_samples

        initial_sample_num = timestamp
        timestamp += self.samples_in_frame

        if self.param.oversampling_factor > 1:
            output_signal = signal.resample_poly(
                output_signal, self.param.oversampling_factor, 1)

        return output_signal, timestamp, initial_sample_num

    def receive_frame(self,
                      rx_signal: np.ndarray,
                      timestamp_in_samples: int,
                      snr_linear_esn0: float) -> Tuple[List[np.ndarray],
                                                       np.ndarray]:
        """Demodulates the signal for a whole received frame.

        Args:
            rx_signal(numpy.ndarray): N x S array containg the received signal, with N the number of receive antennas
                and S the number of samples left in the drop.
            timestamp_in_samples(int): timestamp of initial sample in received signal, relative to the first sample in
                the simulation drop
            snr_linear_esn0 (float): ES/N0 (for equalization).

        This method extracts a signal frame from 'rx_signal' and demodulates it according to the frame and modulation
        parameters.

        Returns:
            (list[np.ndarray], np.ndarray)_
                `list[numpy.ndarray]`: list of detected blocks of bits. Currently the whole frame is
                considered a single block of bits.
                `numpy.ndarray`: N x S' array containing the remaining part of the signal, after this frame was
                    demodulated.  S' = S - self.samples_in_frame
        """

        if rx_signal.shape[1] < self.samples_in_frame:
            bits = None
            rx_signal = np.array([])
        else:
            bits = np.array([])
            frame_signal = rx_signal[:, :self.samples_in_frame]
            rx_signal = rx_signal[:, self.samples_in_frame:]

            channel_estimation = self.channel_estimation(
                rx_signal, timestamp_in_samples)

            if self.param.oversampling_factor > 1:
                frame_signal = signal.decimate(
                    frame_signal, self.param.oversampling_factor)

            for frame_element in self.param.frame_structure:

                if frame_element.type == self.param.link_direction:

                    # get channel estimation for this symbol
                    channel_in_freq_domain = channel_estimation[:, 0]
                    if channel_in_freq_domain.size:
                        channel_estimation = channel_estimation[:, 1:]

                    bits_in_ofdm_symbol = self.detect_data_symbol(
                        frame_signal,
                        channel_in_freq_domain,
                        snr_linear_esn0
                    )
                    bits = np.append(bits, bits_in_ofdm_symbol)

                frame_signal = frame_signal[:,
                                            frame_element.number_of_samples:]
                timestamp_in_samples += frame_element.number_of_samples * \
                    self.param.oversampling_factor

        return list([bits]), rx_signal

    def create_data_symbol(self,
                           symbols_in_frame: np.ndarray,
                           cyclic_prefix_samples: int) -> Tuple[np.ndarray,
                                                                np.ndarray]:
        """Generates a data OFDM symbol in the time domain

        Args:
            symbols_in_frame(numpy.ndarray): 1D array with the remaining frequency-domain modulation symbols in the
                frame. The array should of size KF, with K the number of occupied subcarriers and F the number of
                remaining data symbols in the frame. Only the first K symbols are used.

            cyclic_prefix_samples(int): number of samples in cyclic prefix

        Returns:
            (np.ndarray, np.array):
                `np.ndarray`: time-domain samples of OFDM symbol with `self.param.number_occupied_subcarriers`
                + `cyclic_prefix_samples` elements
                `np.array`: 1D array with the remaining frequency-domain modulation symbols after this
                symbol is generated. The array is of size K(F-1).
        """
        symbols = symbols_in_frame[0:self.param.number_occupied_subcarriers]
        symbols_in_frame = symbols_in_frame[self.param.number_occupied_subcarriers:]

        ofdm_symbol = self.generate_ofdm_symbol(symbols, cyclic_prefix_samples)

        return ofdm_symbol, symbols_in_frame

    def create_reference_symbol(
            self, cyclic_prefix_samples: int) -> np.ndarray:
        """Generates a reference symbol

        Args:
            cyclic_prefix_samples(int): number of samples in cyclic prefix

        Returns:
            numpy.ndarray:
                 time-domain samples of OFDM symbol with `self.param.number_occupied_subcarriers`
                + `cyclic_prefix_samples` elements
        """
        # generate random reference signal
        symbols = (self._rand.standard_normal(self.param.number_occupied_subcarriers) + 1j *
                   self._rand.standard_normal(self.param.number_occupied_subcarriers)) / np.sqrt(2)

        ofdm_symbol = self.generate_ofdm_symbol(symbols, cyclic_prefix_samples)

        return ofdm_symbol

    def generate_ofdm_symbol(
            self,
            resource_elements: np.ndarray,
            cyclic_prefix_samples: int) -> np.ndarray:
        """Generates a single OFDM symbol

        Args:
            resource_elements(numpy.ndarray): contains information in the data subcarriers of an OFDM symbol
            cyclic_prefix_samples(int): number of samples in cyclic prefix

        Returns:
            numpy.ndarray:
                time-domain samples of OFDM symbol
        """
        freq_domain = np.zeros(self.param.fft_size, dtype=complex)
        if self.param.precoding == "DFT":
            resource_elements = np.fft.fft(resource_elements, norm='ortho')
        freq_domain[self._resource_element_mapping] = resource_elements

        ofdm_symbol = np.fft.ifft(freq_domain, norm='ortho')

        if cyclic_prefix_samples:
            ofdm_symbol = np.concatenate(
                (ofdm_symbol[-cyclic_prefix_samples:], ofdm_symbol))

        return ofdm_symbol

    def detect_data_symbol(
            self,
            frame_signal: np.ndarray,
            channel_in_freq_domain: np.ndarray,
            snr_linear_esn0: float) -> np.ndarray:
        """Detects a data OFDM symbol

        This method detects the data bits from the time-domain samples in an OFDM symbol

        Args:
            frame_signal(numpy.ndarray): array with the received signal in the whole remaining frame
            channel_in_freq_domain(int): channel frequency response estimation. It should be a vector of length equal to
                the FFT size.
            snr_linear_esn0(float): ES/N0.

        Returns:
            (np.ndarray, np.array):
                `np.ndarray`: vector containing the detected bits for this particular symbol
                `np.ndarray`: 1D array with the remaining frequency-domain modulation symbols after this
                symbol is generated. The array is of size K(F-1).
        """
        ofdm_symbol = frame_signal[:,
                                   0:self.param.fft_size].ravel()  # SISO assumed
        symbols = self.demodulate_ofdm_symbol(
            ofdm_symbol,
            channel_in_freq_domain,
            snr_linear_esn0
        )

        bits_in_ofdm_symbol = self._mapping.detect_bits(symbols)
        return bits_in_ofdm_symbol

    def demodulate_ofdm_symbol(
            self,
            ofdm_symbol,
            channel_in_freq_domain,
            snr_linear_esn0: float) -> np.ndarray:
        """Demodulates  a single OFDM symbol

        This method performs the FFT of the time-domain signal and equalizes it with knowledge of the channel frequency
        response.

        Args:
            ofdm_symbol(numpy.ndarray): contains information the received OFDM symbol in time domain
            channel_in_freq_domain(numpy.ndarray): channel estimate in the frequency domain
            snr_linear_esn0(float): ES/N0.

        Returns:
            numpy.ndarray:
                estimate of the frequency-domain symbols at the data subcarriers
        """

        ofdm_symbol = np.fft.fft(ofdm_symbol, norm='ortho')
        if self.param.equalization == "MMSE":
            SNR = (channel_in_freq_domain *
                   np.conj(channel_in_freq_domain))**2 * snr_linear_esn0
            equalizer = 1 / channel_in_freq_domain * (SNR / (SNR + 1))
        else:
            # ZF equalization considering perfect channel state information
            # (SISO only)
            equalizer = 1 / channel_in_freq_domain

        ofdm_symbol = ofdm_symbol * equalizer
        symbols = ofdm_symbol[self._resource_element_mapping]

        if self.param.precoding == "DFT":
            symbols = np.fft.ifft(symbols, norm='ortho')
        return symbols

    def channel_estimation(self, rx_signal: np.ndarray,
                           timestamp_in_samples: int) -> np.ndarray:
        """Performs channel estimation

        This methods estimates the frequency response of the channel for all OFDM symbols in a frame. The estimation
        algorithm is defined in the parameter variable `self.param`.
        Currently only ideal channel estimation is available, either considering the channel state information (CSI)
        only at the beginning/middle/end of the frame (estimation_type='IDEAL_PREAMBLE'/'IDEAL_MIDAMBLE'/
        'IDEAL_POSTAMBLE'), or at every OFDM symbol ('IDEAL').
        Ideal channel estimation extracts the CSI directly from the channel,a and does not use the received signal.

        Args:
            rx_signal(numpy.ndarray): time-domain samples of the received signal over the whole frame
            timestamp_in_samples(int): sample index inside the drop of the first sample in frame

        Returns:
            numpy.ndarray:
                channel estimate in the frequency domain. It is a N x K array, with N
                the FFT size and K the number of data OFDM symbols in the frame.
        """

        if self.param.channel_estimation == 'IDEAL':  # ideal channel estimation at each transmitted OFDM symbol
            channel_in_freq_domain = np.empty((self.param.fft_size, 0))
            for frame_element in self.param.frame_structure:

                if frame_element.type == self.param.link_direction:
                    # get channel estimation in frequency domain
                    channel_timestamp = np.array(
                        timestamp_in_samples / self.param.sampling_rate)

                    channel_in_freq_domain = np.hstack(
                        (channel_in_freq_domain, self.get_ideal_channel_estimation(channel_timestamp)))

                timestamp_in_samples += frame_element.number_of_samples * \
                    self.param.oversampling_factor

        else:  # self.param == 'IDEAL_PREAMBLE', 'IDEAL_MIDAMBLE', 'IDEAL_POSTAMBLE':
            # ideal estimation at a single instant at each frame
            number_of_data_symbols = sum(frame_element.type == self.param.link_direction
                                         for frame_element in self.param.frame_structure)

            if self.param.channel_estimation == 'IDEAL_PREAMBLE':
                channel_timestamp = np.array(
                    timestamp_in_samples / self.param.sampling_rate)
            elif self.param.channel_estimation == 'IDEAL_MIDAMBLE':
                channel_timestamp = np.array(
                    (timestamp_in_samples + self.samples_in_frame / 2) / self.param.sampling_rate)
            elif self.param.channel_estimation == 'IDEAL_POSTAMBLE':
                channel_timestamp = np.array(
                    (timestamp_in_samples + self.samples_in_frame) / self.param.sampling_rate)
            else:
                raise ValueError('invalid channel estimation type')
            channel_in_freq_domain = np.tile(
                self.get_ideal_channel_estimation(channel_timestamp),
                number_of_data_symbols)

        return channel_in_freq_domain

    def get_ideal_channel_estimation(
            self, channel_timestamp: np.array) -> np.ndarray:
        """returns ideal channel estimation

        This method extracts the frequency-domain response from a known channel impulse response. The channel is the one
        from `self.channel`.

        Args:
            channel_timestamp(np.array): timestamp (in seconds) at which the channel impulse response should be
                measured

        Returns:
            float:
                signal energy. If snr_type == "EB/N0(DB)", then the bit energy is returned. For the OFDM
                signal, the average bit energy of all data symbols, including the cyclic prefix overhead, is considered.

        """
        channel_impulse_response = self._channel.get_impulse_response(
            channel_timestamp).ravel()
        symbol_channel_in_freq_domain = np.fft.fft(
            channel_impulse_response,
            n=self.param.fft_size *
            self.param.oversampling_factor)
        if self.param.oversampling_factor > 1:
            symbol_channel_in_freq_domain = np.delete(symbol_channel_in_freq_domain, slice(
                int(self.param.fft_size / 2), -int(self.param.fft_size / 2)))
        symbol_channel_in_freq_domain = symbol_channel_in_freq_domain[:, np.newaxis]
        return symbol_channel_in_freq_domain

    def get_bit_energy(self) -> float:
        """returns the theoretical (discrete) bit energy.

        Returns:
            float:
                raw bit energy. For the OFDM signal, the average bit energy of all data symbols, including
                the cyclic prefix overhead, is considered.
        """

        return self.param.oversampling_factor / \
            self._mapping.bits_per_symbol * self._cyclic_prefix_overhead

    def get_symbol_energy(self) -> float:
        """returns the theoretical symbol energy.

        Returns:
            float:
                raw symbol energy. For the OFDM signal, the average energy of a data resource element,
                including the cyclic prefix overhead, is considered.
        """

        return self.param.oversampling_factor * self._cyclic_prefix_overhead

    def get_power(self) -> float:
        return self.param.number_occupied_subcarriers / self.param.fft_size
